const fs = require('fs');
const path = require('path');
const { logger } = require('./logger');
const { dbManager } = require('../config/dbManager');

/**
 * A utility to check and track vulnerabilities exploited by users
 * This is used for educational purposes to track user progress
 */
class VulnerabilityChecker {
  constructor() {
    // OWASP Top 10 (2021) vulnerability categories
    this.categories = {
      'A01': 'Broken Access Control',
      'A02': 'Cryptographic Failures',
      'A03': 'Injection',
      'A04': 'Insecure Design',
      'A05': 'Security Misconfiguration',
      'A06': 'Vulnerable Components',
      'A07': 'Auth & Identity Failures',
      'A08': 'Software & Data Integrity Failures',
      'A09': 'Logging & Monitoring Failures',
      'A10': 'Server-Side Request Forgery'
    };
    
    this.vulnerabilities = {
      'sql_injection': {
        category: 'A03',
        description: 'SQL Injection',
        patterns: [
          "SELECT.*FROM.*WHERE.*=.*OR.*1=1",
          ".*'.*;--.*",
          ".*\".*;--.*",
          ".*OR.*TRUE.*--"
        ]
      },
      'nosql_injection': {
        category: 'A03',
        description: 'NoSQL Injection',
        patterns: [
          "\\{\\$ne:",
          "\\{\\$gt:",
          "\\{\\$regex:"
        ]
      },
      'xss': {
        category: 'A03',
        description: 'Cross-Site Scripting (XSS)',
        patterns: [
          "<script>.*</script>",
          "javascript:",
          "onerror=",
          "onload="
        ]
      },
      'command_injection': {
        category: 'A03',
        description: 'Command Injection',
        patterns: [
          ";.*ls",
          "\\|.*cat",
          "&&.*whoami"
        ]
      },
      'path_traversal': {
        category: 'A01',
        description: 'Path Traversal',
        patterns: [
          "\\.\\./",
          "%2e%2e/"
        ]
      },
      'idor': {
        category: 'A01',
        description: 'Insecure Direct Object Reference',
        patterns: []  // This is mostly tracked by request patterns
      },
      'ssrf': {
        category: 'A10',
        description: 'Server-Side Request Forgery',
        patterns: [
          "localhost",
          "127.0.0.1",
          "0.0.0.0",
          "internal-"
        ]
      },
      'jwt_tampering': {
        category: 'A02',
        description: 'JWT Token Tampering',
        patterns: []  // This needs special handling
      }
    };
  }

  /**
   * Check if a string contains any vulnerability patterns
   * @param {string} input - The string to check
   * @param {string} type - The type of vulnerability to check for
   * @returns {boolean} - True if a vulnerability pattern is found
   */
  checkForVulnerability(input, type) {
    if (!input || !type || !this.vulnerabilities[type]) {
      return false;
    }

    const vulnerability = this.vulnerabilities[type];
    for (const pattern of vulnerability.patterns) {
      const regex = new RegExp(pattern, "i");
      if (regex.test(input)) {
        logger.debug(`Detected ${vulnerability.description} vulnerability: ${input}`);
        return true;
      }
    }
    return false;
  }

  /**
   * Track an exploited vulnerability for user progress
   * @param {string} userId - The user ID
   * @param {string} type - The vulnerability type
   * @param {object} db - Database connection
   */
  async trackExploit(userId, type, db) {
    if (!userId || !type || !db) {
      return;
    }

    try {
      let vulnerability = this.vulnerabilities[type];
      if (!vulnerability) return;
      
      // Track the exploit in the database for user progress
      // This is intentionally insecure with direct SQL
      if (db.client && db.client.config && db.client.config.client === 'sqlite3') {
        // For SQLite
        await db.raw(`
          INSERT OR IGNORE INTO vulnerability_exploits (user_id, vulnerability_type, category, timestamp)
          VALUES (?, ?, ?, datetime('now'))
        `, [userId, type, vulnerability.category]);
      } else {
        // For MongoDB
        const VulnerabilityExploit = require('mongoose').model('VulnerabilityExploit');
        await VulnerabilityExploit.findOneAndUpdate(
          { userId, vulnerabilityType: type },
          { 
            userId, 
            vulnerabilityType: type,
            category: vulnerability.category,
            timestamp: new Date()
          },
          { upsert: true }
        );
      }
      logger.info(`User ${userId} successfully exploited ${vulnerability.description}`);
    } catch (error) {
      logger.error(`Error tracking vulnerability exploit: ${error.message}`);
    }
  }

  /**
   * Get all vulnerability categories
   * @returns {object} - The vulnerability categories
   */
  getCategories() {
    return this.categories;
  }

  /**
   * Get all known vulnerabilities
   * @returns {object} - The vulnerabilities
   */
  getVulnerabilities() {
    return this.vulnerabilities;
  }

  /**
   * Get details of a specific vulnerability category
   * @param {string} categoryId - The category ID (A01-A10)
   * @returns {object} - The category details
   */
  getCategoryDetails(categoryId) {
    if (!categoryId || !this.categories[categoryId]) {
      return null;
    }
    
    const categoryName = this.categories[categoryId];
    const vulnerabilitiesInCategory = Object.entries(this.vulnerabilities)
      .filter(([_, vuln]) => vuln.category === categoryId)
      .map(([key, vuln]) => ({
        id: key,
        name: vuln.description
      }));
    
    return {
      id: categoryId,
      name: categoryName,
      vulnerabilities: vulnerabilitiesInCategory
    };
  }
}

/**
 * Records when a vulnerability has been exploited for training purposes
 * @param {string} type - The vulnerability type (e.g., 'A01')
 * @param {string} endpoint - The API endpoint 
 * @param {object} req - Express request object
 * @param {string} details - Additional details about the exploitation
 */
const recordVulnerabilityExploited = async (type, endpoint, req, details) => {
  try {
    const db = dbManager.getDb();
    const userId = req.user ? req.user.id : null;
    const ipAddress = req.ip || req.connection.remoteAddress;
    
    logger.warn(`[VULNERABILITY EXPLOITED] Type: ${type}, Endpoint: ${endpoint}, IP: ${ipAddress}, Details: ${details}`);
    
    if (db.type === 'sqlite') {
      await db.connection('vulnerability_logs').insert({
        vulnerability_type: type,
        endpoint,
        user_id: userId,
        ip_address: ipAddress,
        details,
        created_at: new Date().toISOString()
      });
    } else if (db.type === 'mongodb') {
      const VulnerabilityLog = require('../models/mongo/VulnerabilityLog');
      await VulnerabilityLog.create({
        vulnerabilityType: type,
        endpoint,
        userId,
        ipAddress,
        details,
        createdAt: new Date()
      });
    }
  } catch (error) {
    logger.error(`Failed to record vulnerability exploitation: ${error.message}`);
  }
};

/**
 * Check if the given request might be exploiting a vulnerability
 * This is used for training purposes to track user progress
 * @param {object} req - Express request object
 * @param {string} vulnerabilityType - The type of vulnerability (e.g., 'A01') 
 * @param {Function} checkFn - Function that returns true if exploit is detected
 */
const detectVulnerabilityExploit = (req, vulnerabilityType, checkFn) => {
  if (checkFn(req)) {
    const endpoint = req.originalUrl;
    const details = JSON.stringify({
      method: req.method,
      body: req.body,
      query: req.query,
      params: req.params
    });
    
    recordVulnerabilityExploited(vulnerabilityType, endpoint, req, details);
    return true;
  }
  return false;
};

/**
 * Common detection functions for vulnerabilities
 */
const detectors = {
  // SQL Injection detection
  sqlInjection: (req) => {
    const inputs = [
      ...Object.values(req.query || {}),
      ...Object.values(req.params || {}),
      ...Object.values(req.body || {})
    ];
    
    const sqlPatterns = [
      /'\s*OR\s*['"]?[0-9]+['"]?\s*=\s*['"]?[0-9]+['"]?/i,
      /'\s*OR\s*['"]?1['"]?\s*=\s*['"]?1['"]?/i,
      /'\s*OR\s*['"]?TRUE['"]?/i,
      /'\s*;\s*DROP\s+TABLE/i,
      /'\s*;\s*DELETE\s+FROM/i,
      /'\s*UNION\s+SELECT/i,
      /'\s*--\s+/i
    ];
    
    return inputs.some(input => {
      if (typeof input !== 'string') return false;
      return sqlPatterns.some(pattern => pattern.test(input));
    });
  },
  
  // NoSQL Injection detection
  noSqlInjection: (req) => {
    // Check for common NoSQL injection patterns
    const hasNonStringOperators = (obj) => {
      if (!obj || typeof obj !== 'object') return false;
      
      return Object.entries(obj).some(([key, value]) => {
        if (key === '$gt' || key === '$ne' || key === '$in' || key === '$regex') {
          return true;
        }
        if (typeof value === 'object') {
          return hasNonStringOperators(value);
        }
        return false;
      });
    };
    
    return hasNonStringOperators(req.body) || hasNonStringOperators(req.query);
  },
  
  // XSS detection
  xss: (req) => {
    const inputs = [
      ...Object.values(req.query || {}),
      ...Object.values(req.body || {})
    ];
    
    const xssPatterns = [
      /<script[\s\S]*?>/i,
      /javascript:/i,
      /on\w+\s*=\s*["']/i,
      /alert\s*\(/i
    ];
    
    return inputs.some(input => {
      if (typeof input !== 'string') return false;
      return xssPatterns.some(pattern => pattern.test(input));
    });
  },
  
  // Path Traversal detection
  pathTraversal: (req) => {
    const inputs = [
      ...Object.values(req.query || {}),
      ...Object.values(req.params || {}),
      ...Object.values(req.body || {})
    ];
    
    return inputs.some(input => {
      if (typeof input !== 'string') return false;
      return input.includes('../') || input.includes('..\\');
    });
  },
  
  // Command Injection detection
  commandInjection: (req) => {
    const inputs = [
      ...Object.values(req.query || {}),
      ...Object.values(req.params || {}),
      ...Object.values(req.body || {})
    ];
    
    const cmdPatterns = [
      /;\s*\w+/i,
      /\|\s*\w+/i,
      /`.*?`/,
      /\$\(.*?\)/
    ];
    
    return inputs.some(input => {
      if (typeof input !== 'string') return false;
      return cmdPatterns.some(pattern => pattern.test(input));
    });
  },
  
  // SSRF detection
  ssrf: (req) => {
    const inputs = [
      ...Object.values(req.query || {}),
      ...Object.values(req.body || {})
    ];
    
    // Check for internal IP addresses or localhost
    const ssrfPatterns = [
      /^https?:\/\/(localhost|127\.0\.0\.1)/i,
      /^https?:\/\/192\.168\./i,
      /^https?:\/\/10\./i,
      /^https?:\/\/172\.(1[6-9]|2[0-9]|3[0-1])\./i,
      /^file:\/\//i
    ];
    
    return inputs.some(input => {
      if (typeof input !== 'string') return false;
      return ssrfPatterns.some(pattern => pattern.test(input));
    });
  }
};

module.exports = {
  VulnerabilityChecker: VulnerabilityChecker,
  recordVulnerabilityExploited,
  detectVulnerabilityExploit,
  detectors
};
